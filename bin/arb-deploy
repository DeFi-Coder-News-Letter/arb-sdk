#!/usr/bin/env python3

# Copyright 2019, Offchain Labs, Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

### ----------------------------------------------------------------------------
### arb-deploy
### ----------------------------------------------------------------------------

import argparse
import datetime
import os
import pkg_resources
import platform
import subprocess
import sys

# package configuration
NAME = 'arb-deploy'
DESCRIPTION = 'Manage Arbitrum dockerized deployments'
__version__ = pkg_resources.require(NAME)[0].version

# filename constants
DOCKER_COMPOSE_FILENAME='docker-compose.arb-deploy.yml'
VALIDATOR_STATE_DIRNAME='validator-states/validator'

# Relative dir name for deployment dependencies
DEPLOY_DIR='compose'

# Dependency type
JS = 'js'
GO = 'go'
CPP = 'cpp'

# 'vers' is the pinned release version
DEPS = {
    'arb-ethbridge': {
        'lang': JS,
        'vers': 'v0.1.0',
    },
    'arb-validator': {
        'lang': GO,
        'vers': 'v0.1.0',
    },
    'arb-avm-cpp': {
        'lang': CPP,
        'vers': 'master',
    },
    'arb-avm': {
        'lang': GO,
    },
    'arb-util': {
        'lang': GO,
    },
    'arb-truffle-provider': {
        'lang': JS,
    },
    'arb-ethers-provider': {
        'lang': JS,
    },
    'arb-web3-provider': {
        'lang': JS,
    },
}
FLAT_DEPS = sorted([dep for dep in DEPS])
JS_DEPS = [d for d in DEPS if DEPS[d]['lang'] == JS]

DEPS_HIERARCHY = {
    'arb-ethbridge': [],
    'arb-validator': ['arb-util', 'arb-avm', 'arb-avm-cpp'],
    'arb-truffle-provider': [],
    'arb-web3-provider': ['arb-ethers-provider'],
}
FLAT_DEPS_HIERARCHY = sorted(
    [dep for dep in DEPS_HIERARCHY] +
    [dep for deps in DEPS_HIERARCHY.values() for dep in deps]
)

if FLAT_DEPS != FLAT_DEPS_HIERARCHY:
    raise AssertionError('Every dependency in DEPS must be included once and only once in DEPS_HIERARCHY')

# ('repository', 'executable name')
EXTERNAL_DEPS = [
    ('arb-sdk', 'arb-deploy'),
    ('arbc-solidity', 'arbc-truffle-compile'),
]
FLAT_EXTERNAL_DEPS = [dep[0] for dep in EXTERNAL_DEPS]

ALL_DEPS = FLAT_DEPS + FLAT_EXTERNAL_DEPS

# Formatting
RED= '\033[91m'
BOLD='\033[1m'
END='\033[0m'

### ----------------------------------------------------------------------------
### docker-compose template
### ----------------------------------------------------------------------------

# Parameters: mnemonic, number of validators, gas per wallet, gas limit, verbose,
# absolute path to state folder, absolute path to contract
COMPOSE_HEADER=(
"""# Machine generated by `arb-deploy`. Do not version control.
version: '3'
services:
    arb-ethbridge:
        image: arb-ethbridge
        build:
            context: %s
            args:
                MNEMONIC: '%s'
                NUM_WALLETS: %d
                NUM_VALIDATORS: %d
                GAS_PER_WALLET: %d
                GAS_LIMIT: %d
                BLOCK_TIME: %d
                VERBOSE: '%s'
                PORT: 7545
                CANARY_PORT: 17545
        ports:
            - '7545:7545'
            - '17545:17545'

    arb-validator-coordinator:
        depends_on:
            - arb-ethbridge
        volumes:
            - %s:/home/user/state
            - %s:/home/user/contract.ao
        image: arb-validator
        build:
            context: %s
            dockerfile: %s
            args:
                WAIT_FOR: 'arb-ethbridge:17545'
                ETH_URL: 'ws://arb-ethbridge:7545'
                ID: 0
                AVM: %s
        ports:
            - '1235:1235'
            - '1236:1236'
""")

def compose_header(cethbridge, mnemonic, num_wallets, num_validators,
    gas_per_wallet, gas_limit, block_time, verbose, state_abspath, contract_abspath,
    cvalidator, dockerfile, avm):
    return (COMPOSE_HEADER % (cethbridge, mnemonic, num_wallets, num_validators,
                              gas_per_wallet, gas_limit, block_time, verbose, state_abspath,
                              contract_abspath, cvalidator, dockerfile, avm))

# Parameters: validator id, absolute path to state folder,
# absolute path to contract, validator id
COMPOSE_VALIDATOR=(
"""
    arb-validator%d:
        depends_on:
            - arb-validator-coordinator
        volumes:
            - %s:/home/user/state
            - %s:/home/user/contract.ao
        image: arb-validator
        environment:
            WAIT_FOR: 'arb-validator-coordinator:1236'
            ETH_URL: 'ws://arb-ethbridge:7545'
            COORDINATOR_URL: 'wss://arb-validator-coordinator:1236/ws'
            ID: %d
            AVM: %s
""")

# Returns one arb-validator declaration for a docker compose file
def compose_validator(validator_id, state_abspath, contract_abspath, avm):
    return (COMPOSE_VALIDATOR % (validator_id, state_abspath, contract_abspath,
                                 validator_id, avm))

### ----------------------------------------------------------------------------
### .git/hooks/pre-commit
### ----------------------------------------------------------------------------

GIT_PRE_COMMIT_HOOK_GO=(
"""
#!/bin/sh

# Prevent commit if go.mod contains a replace rule
ERR_MOD="Error: do not commit go.mod without removing all replace rules"
git grep --cached -q "replace .* => .*" go.mod && echo "${ERR_MOD}" && exit 1 \
    || true

# Prevent commit if `gofmt -l .` produces any output
ERR_FMT="Error: please run \`go fmt ./...\` before committing changes"
gofmt -l $(git diff-index --cached --name-only HEAD | grep ".go") | \
    grep -q '^' && echo "${ERR_FMT}" && exit 1 || true
""")

GIT_PRE_COMMIT_HOOK_CPP=(
"""
#!/bin/sh

# Prevent commit if clang-format produces any output
ERR_FMT="Error: please run \`make format\` before committing changes"
git diff-index --cached --name-only HEAD | grep ".h\|\.hpp\|\.c\|\.cpp" | \
    xargs clang-format -style=file -i -fallback-style=none -output-replacements-xml | \
    grep -q "<replacement " && echo "${ERR_FMT}" && exit 1 || true
""")

### ----------------------------------------------------------------------------
### Build cache starter
### ----------------------------------------------------------------------------

DOCKERFILE_CACHE=(
"""
FROM alpine:3.9
RUN mkdir -p /build
FROM scratch
COPY --from=0 /build /build
"""
)

### ----------------------------------------------------------------------------
### Deploy
### ----------------------------------------------------------------------------

# Compile contracts to `contract.ao` and export to Docker and run validators
def deploy(contract_name, n_validators, mnemonic, verbose, gas_per_wallet,
           gas_limit, dev_flag, sudo_flag, build_flag, up_flag, avm, keep_alive,
           block_time):

    # Install dev_mode if flag set and doesn't exist already
    if dev_flag and not os.path.isdir(DEPLOY_DIR):
        install_dev_mode(sudo_flag)

    dev_mode = dev_flag or os.path.isdir(DEPLOY_DIR)

    if dev_mode:
        def bootstrap_build_cache(name):
            # Create dev-mode.Dockerfile to use the build cache
            run('awk \'{ sub(/##DEV_/, "") }1\' %s/%s/Dockerfile > %s/%s/%s'
                % (DEPLOY_DIR, name, DEPLOY_DIR, name, 'dev-mode.Dockerfile'))
            # Bootstrap empty build cache if doesn't exist
            if run('docker images -q %s' % name, check_output=True, quiet=True, sudo=sudo_flag) == '':
                run('mkdir -p %s/.tmp' % DEPLOY_DIR)
                run('echo "%s" > %s/.tmp/Dockerfile' % (DOCKERFILE_CACHE, DEPLOY_DIR))
                run('docker build -t %s %s/.tmp' % (name, DEPLOY_DIR), sudo=sudo_flag)
                run('rm -rf %s/.tmp' % DEPLOY_DIR)
        bootstrap_build_cache('arb-validator')
        bootstrap_build_cache('arb-avm-cpp')
        # Re-link node_modules in case broken (`yarn` may break symlinks)
        if (os.path.isdir('node_modules') and
            os.path.dirname(os.getcwd()) not in JS_DEPS):
            for dep in JS_DEPS:
                run('rm -rf node_modules/%s && ln -sf ../%s/%s node_modules/%s' %
                    (dep, DEPLOY_DIR, dep, dep))

    # Create VALIDATOR_STATE_DIRNAME s if they don't exist
    states_path = os.path.abspath(VALIDATOR_STATE_DIRNAME)
    for i in range(n_validators):
        if not os.path.isdir(VALIDATOR_STATE_DIRNAME + str(i)):
            os.makedirs(states_path + str(i))

    # Check for DOCKER_COMPOSE_FILENAME and halt if running
    if os.path.isfile('./' + DOCKER_COMPOSE_FILENAME):
        run('docker-compose -f ./%s down -t 0' % DOCKER_COMPOSE_FILENAME,
            sudo=sudo_flag, exit_on_error=False)
    # Kill and rm all docker containers and images created by any `arb-deploy`
    ps = "grep 'arb-validator\|arb-ethbridge' | awk '{ print $1 }'"
    if run('docker ps | ' + ps, check_output=True, quiet=True, sudo=sudo_flag) != '':
        run('docker kill $(' + ('sudo ' if sudo_flag else '') + 'docker ps | ' + ps + ')',
            exit_on_error=False, sudo=sudo_flag)
        run('docker rm $(' + ('sudo ' if sudo_flag else '') + 'docker ps -a | ' + ps + ')',
            exit_on_error=False, sudo=sudo_flag)

    # number of wallets
    n_wallets = n_validators + 100

    # dockerfile_dev_mode
    if dev_mode:
        dockerfile = 'dev-mode.Dockerfile'
    else:
        dockerfile = 'Dockerfile'

    def get_context(dep):
        if dev_mode:
            return './%s/%s' % (DEPLOY_DIR, dep)
        else:
            return 'https://github.com/OffchainLabs/%s.git#%s' % (dep, DEPS[dep]['vers'])

    # Overwrite DOCKER_COMPOSE_FILENAME
    compose = os.path.abspath('./' + DOCKER_COMPOSE_FILENAME)
    contract = os.path.abspath(contract_name)
    contents = (
        compose_header(
            get_context('arb-ethbridge'),
            mnemonic,
            n_wallets,
            n_validators,
            gas_per_wallet,
            gas_limit,
            block_time,
            verbose,
            states_path + str(0),
            contract,
            get_context('arb-validator'),
            dockerfile,
            avm,
        ) + ''.join([compose_validator(i, states_path + str(i), contract, avm)
                        for i in range(1, n_validators)]))
    with open(compose, 'w') as f:
        f.write(contents)

    # Build arb-avm-cpp
    if not up_flag or build_flag:
        use_build_cache = ''
        if dev_mode:
            use_build_cache = '-f %s/arb-avm-cpp/%s ' % (DEPLOY_DIR, 'dev-mode.Dockerfile')
        run('docker build -t arb-avm-cpp %s%s' % (use_build_cache, get_context('arb-avm-cpp')))

    # Set keep_alive from True/False flag to command line flag
    if keep_alive:
        keep_alive = ''
    else:
        keep_alive = ' --abort-on-container-exit'

    # Build
    if not up_flag or build_flag:
        run('docker-compose -f %s build' % compose, sudo=sudo_flag)

    # Run
    if not build_flag or up_flag:
        run('docker-compose -f %s up%s' % (compose, keep_alive), sudo=sudo_flag)

# Installs DEPS and links them correctly
def install_dev_mode(sudo_flag):
    GC = ('git clone --recurse-submodules https://github.com/OffchainLabs/%s.git ' +
          DEPLOY_DIR + '/%s')
    os.mkdir(DEPLOY_DIR)
    for dep in DEPS_HIERARCHY:
        run(GC % (dep, dep))
        language_setup(dep)
        for sub_dep in DEPS_HIERARCHY[dep]:
            run(GC % (sub_dep, os.path.join(dep, sub_dep)))
            run('ln -sf %s/%s %s/%s' % (dep, sub_dep, DEPLOY_DIR, sub_dep))
            language_setup(sub_dep, parent=dep)

def language_setup(repo, parent=None):
    if DEPS[repo]['lang'] == JS:
        run('yarn --cwd %s/%s' % (DEPLOY_DIR, repo))
        if os.path.isdir('node_modules'):
            run('rm -rf node_modules/%s && ln -sf ../%s/%s node_modules/%s' %
                (repo, DEPLOY_DIR, repo, repo))
        if parent is not None and DEPS[parent]['lang'] == JS:
            run('rm -rf %s/%s/node_modules/%s && ln -sf ../../%s %s/%s/node_modules/%s' %
                (DEPLOY_DIR, parent, repo, repo, DEPLOY_DIR, parent, repo))
    elif DEPS[repo]['lang'] == GO:
        precommit_hook(os.path.join(DEPLOY_DIR, repo), GIT_PRE_COMMIT_HOOK_GO)
    elif DEPS[repo]['lang'] == CPP:
        precommit_hook(os.path.join(DEPLOY_DIR, repo), GIT_PRE_COMMIT_HOOK_CPP)
    else:
        raise AssertionError('DEP not found or no such language')

def precommit_hook(path, content):
    hookPath = os.path.join(path, '.git', 'hooks', 'pre-commit')
    with open(hookPath, 'w') as f:
        f.write(content)
    run('chmod +x ' + hookPath)

# Run commands in shell
def run(command, sudo=False, exit_on_error=True, quiet=False, check_output=False):
    if sudo:
        command = 'sudo ' + command
    if not quiet:
        print(BOLD + '$ %s\n' % command + END)
    if check_output:
        try:
            return subprocess.check_output(command, shell=True).decode('utf-8')
        except subprocess.CalledProcessError as e:
            if exit_on_error:
                sys.exit(1)
            else:
                return ''
    else:
        retval = os.system(command)
        if exit_on_error and retval != 0:
            sys.exit(1)
        else:
            return retval

### ----------------------------------------------------------------------------
### Command line interface
### ----------------------------------------------------------------------------

# Status
class GitStatusAction(argparse.Action):
    def __init__(self,
                 option_strings,
                 dest=argparse.SUPPRESS,
                 default=argparse.SUPPRESS,
                 help=None):
        super(GitStatusAction, self).__init__(
            option_strings=option_strings,
            dest=dest,
            default=default,
            nargs=0,
            help=help)

    def __call__(self, parser, namespace, values, option_string=None):
        msg = ''
        deploy_dir = ''
        if os.path.isdir(DEPLOY_DIR):
            deploy_dir = os.path.abspath(DEPLOY_DIR)
        elif '/' + DEPLOY_DIR + '/' in (os.path.abspath('.') + '/'):
            deploy_dir = os.path.abspath('.').rsplit(DEPLOY_DIR, 1)[0] + DEPLOY_DIR
        if deploy_dir != '':
            headers = ['Repo', 'Branch', 'Commit ', ' M ']
            def git_status(path):
                """ Returns (branch name, short hash, if is modified) """
                return (run('cd %s && git rev-parse --abbrev-ref HEAD' %
                            path, check_output=True, quiet=True).strip(),
                        run('cd %s && git rev-parse --short HEAD' % path,
                            check_output=True, quiet=True).strip(),
                        run('cd %s && git diff --stat && git diff --stat --cached'
                                 % path, exit_on_error=False, quiet=True, check_output=True) != '')
            def find(repo):
                if os.path.isdir(deploy_dir + '/' + repo):
                    path = deploy_dir + '/' + repo
                else:
                    return [repo, '', '???????', '']
                (branch_nom, short_hash, is_modified) = git_status(path)
                return [repo, branch_nom, short_hash, is_modified]
            data = []
            for dep in DEPS_HIERARCHY:
                data += [find(dep)]
                for sub_dep in DEPS_HIERARCHY[dep]:
                    data += [find(sub_dep)]
            def find_ext_dep(name, cmd):
                bin_path = run('which %s' % cmd, check_output=True, quiet=True).strip()
                file_path = run('cat %s | grep "__file__ ="' % bin_path, check_output=True,
                            quiet=True, exit_on_error=False)[len("__file__ = '"):-1]
                if file_path:
                    parent_dir = os.path.dirname(file_path)
                    (branch_nom, short_hash, is_modified) = git_status(parent_dir)
                else:
                    (branch_nom, short_hash, is_modified) = ("", "???????", False)
                return [name, branch_nom, short_hash, is_modified]
            ext_data = []
            for (name, dep) in EXTERNAL_DEPS:
                ext_data += [find_ext_dep(name, dep)]
            # get status of current project i.e. demo-dapp-pet-shop
            current_name = os.path.splitext(os.path.basename(
                run('git config --get remote.origin.url', check_output=True,
                    quiet=True, exit_on_error=False)))[0].strip()
            if current_name != '' and current_name not in ALL_DEPS:
                (branch_nom, short_hash, is_modified) = git_status(os.getcwd())
                ext_data += [[current_name, branch_nom, short_hash, is_modified]]
            repo_width = max(len(row[0]) for row in [headers] + data + ext_data) + 2
            branch_width = max(len(row[1]) for row in [headers] + data + ext_data) + 2
            commit_width = len('175e1d0') + 2
            total_width = repo_width + branch_width + commit_width + len('[+]')
            msg += ' DEV MODE '.center(total_width, '-') + '\n'
            msg += (headers[0].ljust(repo_width) + headers[1].ljust(branch_width) +
                    headers[2].ljust(commit_width) + headers[3] + '\n')
            def format_row(row):
                return ((RED if '?' in row[2] else BOLD if row[3] else '') +
                        row[0].ljust(repo_width) + row[1].ljust(branch_width) +
                        row[2].ljust(commit_width) + ('[+]' if row[3] else '') +
                        END + '\n')
            for row in data:
                msg += format_row(row)
            msg += ''.center(total_width, '-') + '\n'
            for row in ext_data:
                msg += format_row(row)
            msg += ''.center(total_width, '-') + '\n'
            msg += 'Path: %s\n' % deploy_dir
        else:
            adv = run('arb-deploy --version', check_output=True, quiet=True,
                       exit_on_error=False).strip()
            acv = run('arbc-truffle-compile --version', check_output=True,
                       quiet=True, exit_on_error=False).strip()
            ts = 'Timestamp: %s' % datetime.datetime.now()
            p = ' Platform: %s' % platform.platform()
            total_width = max([len(adv), len(acv), len(ts), len(p)])
            msg += ' arb-deploy '.center(total_width, '-') + '\n'
            msg += adv + '\n' + acv + '\n' + ts + '\n' + p + '\n'
            msg += ' truffle version '.center(total_width, '-') + '\n'
            msg += run('truffle version', check_output=True, quiet=True, exit_on_error=False).strip() + '\n'
            msg += ''.center(total_width, '-') + '\n'
        parser._print_message(msg, sys.stdout)
        parser.exit()

def main():
    parser = argparse.ArgumentParser(
        prog=NAME,
        description=DESCRIPTION)
    # Required
    parser.add_argument('contract',
        help='The Arbitrum bytecode contract to deploy.')
    parser.add_argument('n_validators', type=int,
        help='The number of validators to deploy.')
    # Optional
    parser.add_argument('-s', '--sudo', action='store_true', dest='sudo',
        help='Run docker-compose with sudo. May be helpful for some platforms')

    group = parser.add_mutually_exclusive_group()
    group.add_argument('-b', '--build-only', action='store_true', dest='build_only',
        help='Run docker-compose build only')
    group.add_argument('-u', '--up-only', action='store_true', dest='up_only',
        help='Run docker-compose up only')

    parser.add_argument('-k', '--keep-alive', action='store_true', dest='keep_alive',
        help='Keep docker-compose running even if containers exit')

    parser.add_argument('-a', '--avm', default='cpp', dest='avm',
                        choices=['cpp', 'go', 'test'],
                        help='Control the avm backend (default cpp)')

    parser.add_argument('-m', '--mnemonic', type=str, dest='mnemonic',
        default='jar deny prosper gasp flush glass core corn alarm treat leg smart',
        help='Specify the test Mnemonic for key generation')
    parser.add_argument('-l', '--gasLimit', type=int,
        dest='gas_limit', default=6721975,
        help='The block gas limit in wei on ganache')
    parser.add_argument('-e', '--defaultBalanceEther', type=int,
        dest='gas_per_wallet', default=100,
        help='Amount of ether to assign each test account on ganache')
    parser.add_argument('-b', '--blockTime', type=int,
        dest='block_time', default=1,
        help='Block time in seconds for automatic mining on ganache')

    parser.add_argument('-v', '--verbose', dest='verbose', action='count',
        help='Increase verbosity on ganache')

    parser.add_argument('--status', action=GitStatusAction,
        help='show tooling versions for diagnostics and exit')
    parser.add_argument('-d', '--dev-mode', action='store_true', dest='dev',
        help=(('Downloads dependencies into `%s` and links them if `%s` does ' +
        'not already exist. Note: if `%s` exists in the current working ' +
        'directory then dev-mode will be used automatically')
        % (DEPLOY_DIR, DEPLOY_DIR, DEPLOY_DIR)))

    # Version
    parser.add_argument('--version', action='version',
        version='%(prog)s ' + __version__)

    args = parser.parse_args()

    # Set verbose to Ganache parameter
    verboseFlag = '-q'
    if args.verbose is not None:
        if args.verbose == 1:
            verboseFlag = ''
        elif args.verbose == 2:
            verboseFlag = '-v'
        elif args.verbose > 2:
            verboseFlag = '-v --debug'

    # Deploy
    deploy(args.contract, args.n_validators, args.mnemonic, verboseFlag,
           args.gas_per_wallet, args.gas_limit, args.dev, args.sudo,
           args.build_only, args.up_only, args.avm, args.keep_alive,
           args.block_time)

if __name__ == '__main__':
    try:
        main()
    except KeyboardInterrupt:
        sys.exit(1)
